
    | s_user_block(l :: A.Loc, body :: A.Expr) =>
      expr-to-js(body)

    | s_var(l :: A.Loc, name :: A.Bind, value :: A.Expr) =>
      format("var ~a = ~a", [js-id-of(name.id), expr-to-js(value)])

    | s_let(l :: A.Loc, bind :: A.Bind, value :: A.Expr) =>
      format("var ~a = ~a",[js-id-of(bind.id), expr-to-js(value)])

    | s_assign(l :: A.Loc, id :: String, value :: A.Expr) =>
      format("~a = ~a", [js-id-of(id), expr-to-js(value)])

    | s_if_else(l :: A.Loc, branches :: list.List<IfBranch>, _else :: A.Expr) =>
      elseifs = for list.fold(bs from "", b from branches.rest):
        bs + format("else if (RUNTIME.isTrue(~a)) { return ~a; }", [expr-to-js(b.test), expr-to-js(b.body)])
      end
      do-block(format("if (RUNTIME.isTrue(~a)) { return ~a; } ~a else {return ~a; }",
        [expr-to-js(branches.first.test), expr-to-js(branches.first.body),
          elseifs, expr-to-js(_else)]))

    | s_try(l :: A.Loc, body :: A.Expr, id :: A.Bind, _except :: A.Expr) =>
      do-block(format("try { return ~a; } catch (~a) { ~a = RUNTIME.unwrapException(~a); return ~a; }", [expr-to-js(body), js-id-of(id.id), js-id-of(id.id), js-id-of(id.id), expr-to-js(_except)]))

    | s_lam(l :: A.Loc, params :: list.List<String>, args :: list.List<Bind>, ann :: A.Ann, doc :: String, body :: A.Expr, check :: A.Expr) =>
      fun get-id(bind):
        js-id-of(bind.id)
      end
      format("RUNTIME.makeFunction(function(~a) { return ~a; }, RUNTIME.makeString(~s))", [args.map(get-id).join-str(","), expr-to-js(body), doc])

    | s_method(l :: A.Loc, args :: list.List<A.Bind>, ann :: A.Ann, doc :: String, body :: A.Expr, check :: A.Expr) =>
      format("RUNTIME.makeMethod(function(~a) { return ~a; }, RUNTIME.makeString(~s))", [args.map(fun (x): js-id-of(x.id) end).join-str(","), expr-to-js(body), doc])

    | s_app(_, f, args) =>
      #format("~a.app(~a)", [expr-to-js(f), args.map(expr-to-js).join-str(",")])
      format("RUNTIME.applyFunc(~a, [~a])", [expr-to-js(f), args.map(expr-to-js).join-str(",")])

    | s_obj(_, fields) =>
      fun field-to-js(field):
        format("'~a': ~a", [field.name.s, expr-to-js(field.value)])
      end
      format("RUNTIME.makeObject({~a})", [fields.map(field-to-js).join-str(",")])

    | s_extend(_, super, fields) =>
      fun field-to-js(field):
        format("'~a': ~a", [field.name.s, expr-to-js(field.value)])
      end
      format("~a.extend({~a})", [expr-to-js(super), fields.map(field-to-js).join-str(",")])

    | s_bracket(_, obj, f) =>
      cases (A.Expr) f:
        | s_str(_, s) => format("RUNTIME.getField(~a, '~a')", [expr-to-js(obj), s])
        | else => raise("Non-string lookups not supported")
      end

    | s_colon_bracket(_, obj, field) =>
      cases (A.Expr) field:
        | s_str(_, s) => format("RUNTIME.getRawField(~a, '~a')", [expr-to-js(obj), s])
        | else => raise("Non-string lookups not supported")
      end

    | s_get_bang(l :: A.Loc, obj :: A.Expr, field :: String) =>
      format("RUNTIME.getMutableField(~a, '~a')", [expr-to-js(obj), field])

    | s_update(l :: A.Loc, super :: A.Expr, fields) =>
      fun field-to-js(field):
        format("'~a': ~a", [field.name.s, expr-to-js(field.value)])
      end
      format("~a.mutate({~a})", [expr-to-js(super), fields.map(field-to-js).join-str(",")])

    | s_id(_, id) => 
      js-id-of(id)

    | s_num(_, n) =>
      format("RUNTIME.makeNumber(~a)", [n])

    | s_bool(_, b) =>
      format("RUNTIME.makeBool(~a)", [b])

    | s_str(_, s) =>
      format("RUNTIME.makeString(~s)", [s])
      
    | else => do-block(format("throw new Error('Not yet implemented ~a')", [ast.label()]))